---
alwaysApply: true
---
Ho un progetto web scritto in Next.js (React + TS) generato con V0.dev. Il codice frontend utilizza componenti React, CSS/Tailwind (Shadcn/UI), ed è organizzato in pagine e componenti UI. Voglio convertire questo progetto web in un’app mobile sviluppata con React Native + TypeScript + Expo (managed workflow). La conversione sarà fatta all’interno di una monorepo che include sia il codice web originale (in /legacy-web) sia la nuova app mobile (in /app). Obiettivi Principali:
Conversione Componenti UI: Trasforma tutti i componenti e le pagine web in componenti mobile compatibili con React Native/Expo. In particolare, sostituisci gli elementi HTML/CSS con gli equivalenti React Native: non si possono usare direttamente tag HTML o CSS nel codice React Native
itechburner.weebly.com
. React Native fornisce un proprio set di componenti nativi per costruire l’interfaccia: ad esempio, al posto di <div> o <section> utilizza <View>; al posto di <p> o <span> utilizza <Text>; al posto di <img> (o Next <Image>) utilizza Image di React Native; per <button> o elementi cliccabili utilizza componenti touch come Pressable (o TouchableOpacity in alternativa) con all’interno del testo
. Allo stesso modo:
Sostituisci <input> o <textarea> HTML con il componente <TextInput> di React Native per campi di testo.
Sostituisci <form> e la logica di form submission con funzioni gestite in JavaScript (stato locale e funzioni onPress), poiché su mobile non esiste un analogo diretto del tag form. Puoi implementare la validazione e raccolta dei dati tramite state management di React (ad es. usando useState per ogni campo) e gestire l’evento di submit al click di un bottone/Pressable.
Sostituisci <ul>, <ol> e <li> (liste HTML) con strutture di liste in React Native. Per liste statiche brevi, puoi mappare i dati in più <View>/<Text>. Per liste lunghe o dinamiche, usa componenti ottimizzati come <FlatList> o <SectionList> che gestiscono in modo efficiente molti elementi.
Sostituisci elementi HTML semantici o non supportati (es. <header>, <footer>, <article>, <main>, ecc.) semplicemente con <View> o altri container appropriati, applicando stili per ottenere il layout desiderato.
Componenti UI di librerie web: Se il codice Next.js usa librerie/componenti web-specifiche (es. componenti di Shadcn/UI o altre librerie React DOM), sostituiscili con equivalenti per React Native. Ad esempio: un Button di Shadcn/UI va rimpiazzato con un componente touch nativo (Pressable + <Text> con stile), un Dialog/modal web va sostituito con il componente Modal di React Native (o librerie compatibili con Expo), menu a tendina web con Picker o ActionSheet nativi, e così via.
Rimuovi o sostituisci qualsiasi dipendenza non compatibile con l’ambiente mobile. Se una libreria utilizza direttamente il DOM del browser (metodi come document.getElementById o API Web), ciò non funzionerà in React Native. Elimina queste parti o trova alternative native. Ad esempio, se si utilizzava una libreria per animazioni web, sostituirla con react-native-reanimated o analoghe librerie compatibili con RN; se c’era un componente di date picker web, usare un DatePicker native (ci sono vari componenti community Expo-friendly). In generale, nessuna chiamata a window o document deve rimanere nel codice mobile.
TypeScript & Struttura del Codice: Utilizza TypeScript ovunque. I file dei componenti/pages React Native saranno .tsx (JSX + TS). Mantieni la stessa logica/struttura del codice per quanto possibile, semplicemente traducendola in sintassi React Native. Definisci i tipi per Props e State di componenti se erano presenti nel progetto web (es. se un componente aveva prop1, assicurati di definire l’interfaccia/Type corrispondente in TS).
Organizza i file RN in modo chiaro, similmente al progetto web: ad esempio potresti creare una cartella components/ sotto /app per componenti riutilizzabili convertiti, e usare la cartella app/ (fornita da Expo Router, vedi punto Routing) per le schermate principali.
Non miscelare il codice web e mobile: la directory /legacy-web rimarrà invariata con il suo codice Next.js originale, mentre nuovi file verranno creati in /app per la versione mobile. Se vuoi riutilizzare qualche logica (es. funzioni helper pure) tra web e mobile, considera di spostarle in un pacchetto condiviso (es. directory packages/util nella monorepo) da cui importare sia in Next che in RN. Ma non importare componenti React web direttamente dentro l’app mobile – vanno convertiti.
Stili e CSS: Il progetto originale usa CSS (Tailwind) per il layout e lo stile. React Native non supporta file CSS esterni o classi CSS come sul web
. Dovrai quindi convertire gli stili in uno dei seguenti modi:
StyleSheet API: Puoi creare oggetti di stile usando StyleSheet.create in React Native, oppure definire oggetti JS inline per i vari elementi. Ad esempio, una classe Tailwind come text-center bg-gray-100 p-4 rounded corrisponderà a proprietà RN: { textAlign: 'center', backgroundColor: '#f5f5f5', padding: 16, borderRadius: 8 } (notare che Tailwind usa unità 4px per default). Questo può essere fatto manualmente per ogni stile utilizzato nel web.
Tailwind -> NativeWind: In alternativa, puoi utilizzare la libreria NativeWind che permette di usare classi Tailwind direttamente nei componenti React Native (è un adattatore Tailwind per RN). Dato che il progetto è già in Tailwind, questa opzione potrebbe accelerare la migrazione: i utility classes esistenti (es. bg-red-500, mt-4, text-xl, ecc.) potranno funzionare in RN se configuri NativeWind. Assicurati di installare e configurare nativewind e di avvolgere l’app con il suo provider se necessario. (È interessante notare che esiste un tool CLI chiamato ntrn che automatizza la conversione Next->RN e supporta la traduzione automatica di Tailwind in NativeWind
dev.to
).
Componenti Shadcn/UI: Molti componenti Shadcn (es. bottoni, modali, tooltip) usano Tailwind per lo styling e dipendono da Radix UI (per funzionalità interattive web). Non essendoci Radix su mobile, dovrai sostituire la funzionalità: es. un tooltip potrebbe non essere fondamentale su mobile touch e si può omettere, oppure implementare in altro modo se necessario. Lo stile invece, come detto, va tradotto via StyleSheet o NativeWind.
Font e icone: Se il progetto web utilizzava webfont o icone (es. Heroicons via @heroicons/react), su Expo dovrai aggiungere i file di font tramite Expo Font (o Google Fonts package) e usare <Text style={{fontFamily: ...}}>. Per le icone, puoi usare librerie come @expo/vector-icons che coprono FontAwesome, Material Icons etc., oppure trovare equivalenti delle icone utilizzate. Nel prompt puoi chiedere all’assistente di occuparsi anche di configurare i font/icones se necessario.
Layout Responsivo Mobile-First: Assicurati che il design risultante sia mobile-first e si adatti a diverse dimensioni di schermo (smartphone di varie risoluzioni, tablet se previsto). In React Native il layout utilizza il sistema Flexbox di default, quindi sfrutta flexbox per creare interfacce che riempiano lo schermo in modo flessibile e si riadattino
hatimeria.com
. Evita di usare dimensioni fisse in pixel per larghezze/altezze quando possibile; meglio usare % o dimensioni relative, oppure la proprietà flex per distribuire lo spazio.
Usa <ScrollView> per contenuti che eccedono la dimensione dello schermo verticalmente (liste, pagine scorrevoli) o orizzontalmente. <ScrollView> consente scrolling ma carica tutti gli elementi immediatamente, quindi per liste lunghe come detto preferisci <FlatList> che rende solo gli elementi visibili migliorando le performance
hatimeria.com
.
Considera l’uso di <SafeAreaView> all’esterno del layout (specialmente su iOS) per evitare che contenuti importanti finiscano sotto notch, status bar o bordi arrotondati. In Expo, puoi importare SafeAreaView da react-native-safe-area-context.
Verifica la UI su diversi schermi: elementi come margini, padding, font-size dovranno magari essere regolati rispetto alla versione web per essere leggibili su mobile (ad es. un font 1rem ≈ 16px sul web potrebbe andare bene, ma testi molto grandi o piccoli vanno rivisti provandoli sul device).
Routing e Navigazione: Converti le rotte/pagine di Next.js in un sistema di navigazione mobile. Idealmente, utilizzeremo Expo Router per avere un routing basato su filesystem simile a Next.js. Expo Router consente di definire le schermate creando file nella cartella /app del progetto Expo, in maniera analoga alle pagine Next
Mappatura delle pagine: Crea all’interno di my-project/app/ (cartella dell’app Expo) un file .tsx per ogni route della web app. Ad esempio, se in Next.js esisteva pages/index.tsx (homepage) e pages/about.tsx, crea app/index.tsx e app/about.tsx nell’app mobile. Allo stesso modo, per rotte nidificate o dinamiche: es. pages/products/[id].tsx in Next diventa app/products/[id].tsx nell’app Expo Router. Expo Router supporta parametri dinamici con la stessa sintassi delle parentesi quadre.
Layout condivisi: Next.js Pages Router ha il file _app.js/_app.tsx per definire il layout comune. Next 13 App Router usa layout.tsx. In Expo Router si utilizza un file speciale _layout.tsx per definire un layout/navigatore comune alle pagine di una cartella. Implementa un _layout.tsx nella directory app/ principale come RootLayout: qui puoi impostare un navigatore di base (StackNavigator) e eventuali provider (es. contesto tema, SafeArea) che vuoi siano comuni. (Expo Router costruisce su React Navigation: puoi usare <Stack> e <Stack.Screen> come faresti definendo un navigator, ma dichiarandolo nel layout file).
Navigazione tra schermate: Aggiorna i link interni. In Next si usava il componente <Link> di Next per navigare client-side; in Expo Router c’è un componente analogo <Link> da expo-router che puoi usare dentro <Text> o <Pressable>, oppure puoi usare il hook useRouter() di expo-router per imperativamente fare router.push("rotaDestinazione"). Altrimenti, se preferisci, puoi usare direttamente le API di React Navigation (visto che Expo Router è basato su esse). Importante: assicurati che la navigazione rispecchi la struttura logica dell’app originale.
Alternative al file-based routing: Se Expo Router risultasse non praticabile, è accettabile usare manualmente React Navigation per definire le schermate. In tal caso dovresti: creare un file App.tsx che contiene un <NavigationContainer> con all’interno i navigator (Stack, Tab, Drawer a seconda dei casi). Definisci le screen con lo stesso contenuto delle pagine Next. (Tuttavia, Expo Router è consigliato per consistenza con il paradigma Next
).
Migrazione della Logica Client e Funzionalità: Porta sul mobile tutte le funzionalità lato client (frontend) che hanno senso in un contesto mobile, adattandole se necessario:
Stato e logica di business: Se i componenti React web usavano hook come useState, useEffect, useContext ecc., questa logica può spesso essere riutilizzata tal quale nei componenti React Native. Mantieni la gestione dello stato per interfacce modali, toggles, form input, ecc.
Eventi e interazioni: Adatta gli handler di eventi DOM ai gestori RN: ad esempio, in luogo di onClick usare onPress, in luogo di onChange (per input HTML) usare onChangeText per TextInput, ecc. Rimuovi ogni riferimento ad eventi non esistenti su mobile (es. onMouseEnter, hover effects – su mobile non c’è hover; se necessario implementare feedback di pressione, usa Pressable con onPressIn/onPressOut o la prop hovered se usi librerie come Dripsy per web).
Autenticazione e storage: Se l’app web usa cookie, localStorage o sessionStorage per memorizzare token/sessioni, su React Native dovrai usare alternative come SecureStore di Expo, AsyncStorage o il context di autenticazione. Non c’è il concetto di cookie automatici, quindi eventuali chiamate fetch da mobile dovranno includere token auth in header manualmente. Adatta dunque la gestione di login/token utilizzando le API di storage mobile.
Chiamate API e dati: Qualsiasi chiamata a API REST o GraphQL che il frontend web faceva (ad esempio con fetch/axios in useEffect) può essere mantenuta, a patto che l’endpoint sia accessibile dal dispositivo mobile. Se il progetto Next utilizzava API Routes (es. /api/…) come backend interno, dovrai invece prevedere un vero backend esterno raggiungibile dall’app (potrebbe essere necessario deployare quelle API separatamente, o usare direttamente i servizi originali come Supabase da mobile). In breve, lato mobile le data-fetching functions di Next (getServerSideProps, getStaticProps) non esistono; dovrai chiamare le API nel runtime dell’app (ad es. dentro useEffect in una schermata RN) e gestire loading state.
Funzionalità di Next.js non rilevanti sul mobile: Ignora o rimuovi concetti come Server-Side Rendering per le pagine (l’app mobile è client-side only), code splitting di Next (su mobile la bundler Metro gestisce il bundling diversamente), e tutto ciò che è Next-specific (es. file next.config.js, import di next/head, image optimization di Next). Queste parti non devono comparire nella app mobile.
SEO e meta-tag: Non rilevanti per un’app mobile. Quindi componenti come <Head> di Next.js o meta description, etc., possono essere omessi. Se l’app aveva funzionalità di sharing link (Open Graph tags ecc.), su mobile potrebbe interessare integrare deep linking o App Linking, ma è un tema avanzato separato.
Componenti interattivi specifici: modali, tooltip, popover, ecc. In React Native implementa modali usando il componente <Modal> o librerie come react-native-modal. Per dropdown/selector usa Picker o ActionSheet. In generale, assicurati che ogni pattern di interazione abbia una controparte mobile intuitiva.
Performance e Best Practice Mobile: Segui le best practice di React Native per assicurare una buona performance e usabilità:
Mantieni i componenti snelli. Evita di bloccare il thread principale con calcoli pesanti; se devi fare operazioni costose (es. formattazione di grossi dataset) considera di eseguirle fuori dal rendering, magari utilizzando Web Workers o librerie come react-native-reanimated per animazioni complesse.
Usa i componenti appropriati: come già detto, per liste lunghe usa FlatList, per layout complessi suddividi in componenti riutilizzabili, ecc. Adotta la navigazione nativa (React Navigation/Expo Router) invece di soluzioni fatte in casa, per ottenere gesture e performance nativi.
Ricordati di testare sia su Android che iOS se possibile, e adeguare eventuali differenze (ad es. alcuni comportamenti di stile o font rendering possono differire). Se necessario, puoi usare la classe Platform di RN per gestire piccole differenze (es: padding extra su Android vs iOS).
Implementa l’handling della tastiera nelle schermate con form: assicurati che i campi di input non siano coperti dalla tastiera software. Puoi avvolgere contenuti in KeyboardAvoidingView e/o usare scroll automatico quando un TextInput è focalizzato, per una UX ottimale nei form.
Commenti e Chiarezza del Codice: Nel codice convertito, mantieni dei commenti che spieghino le scelte di conversione più importanti, così da facilitare l’apprendimento e la manutenzione futura. Ad esempio, all’inizio di un componente convertito, inserisci un commento che indichi da quale file originale Next.js proviene. Oppure all’interno del JSX, commenta parti come: // Replaced Next.js <div> with React Native <View> o // Using Pressable instead of <button> for touch support. Questi commenti saranno utili per capire rapidamente le corrispondenze tra il vecchio codice web e il nuovo codice mobile.
Inoltre, includi commenti per giustificare eventuali modifiche di design o UX fatte durante la conversione (ad es. “// Combined two screens into one for mobile simplicity”, se capita di unire pagine).
Mantieni la consistenza nella codestyle: se usavi ESLint/Prettier nel progetto web, applicali anche qui. Expo di default supporta un certo TSConfig e linting; cerca di uniformare lo stile a quello del progetto esistente (naming, struttura dei componenti).
Output atteso dall’assistente AI:
– Codice React Native completo per ogni componente e pagina convertita, in file .tsx separati, organizzato nella struttura descritta (cartella /app).
– Configurazione di base di Expo (App.tsx, app.json, package.json con dipendenze necessarie).
– Eventuale file di routing (se non si usa Expo Router, allora fornire codice di configurazione React Navigation).
– Per ciascun file di pagina/componente convertito, presenza di commenti esplicativi come richiesto.
– Suggerimenti per eventuali dipendenze aggiuntive da installare (es: nativewind, expo-linear-gradient se veniva usato un background gradient CSS, ecc.), elencandole nel prompt o commenti.
– (Facoltativo): Breve spiegazione finale di come avviare l’app mobile (ad es. comandi npm install, npx expo start, ecc.), e conferma che il codice è compatibile con l’Expo managed workflow (quindi nessuna configurazione nativa extra necessaria).
